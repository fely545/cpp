### Introduction
There are interruptions that come up in your program, which are delivered to a process that runs on an operating system and pauses the running process.

When the interruptions are generated, they force-stop the OS on its task, prematurely terminating the running program, and the task for which the interrupt was generated is attended to.

These interrupts are called `signals`. The signals can be generated by pressing `Ctrl+C` on various operating systems (Windows, Mac OS X, LINUX, or UNIX).

When using the C++ programming language, the interrupts can be handled in the above-mentioned operating systems.

But before we go into signal handling in C++, you may want to know a little about the programming language.

### What is C++ programming language?
C++ is a general-purpose cross-platform programming computer language, which is case-sensitive and free-form. 

The language is highly flexible and scalable and gives programmers an optimized level of control over system memory and resources. It is used for the development of operating systems (OS), browsers, apps, games, software, Graphical User Interfaces (GUIs), etc.

The imperative and compiled language is a powerful framework that supports different methods of programming such as object-oriented paradigm, functional programming, generic programming, and procedural programming.

### Signal handling in C++
We understand that signals are interrupts that stop an OS in its task to attend to another task, and to stop these actions, the signals need to be handled.

In C++, signals are provided by the language which can handle the interrupts. They catch the interrupting signals and solve the problem that causes the program to pause while executing its task.

Below is the signal library of C++; signals that a developer can work with and their operations:


####Signals	operations
1. `SIGINT`(Signal Interrupt) - This signal is used to generate an interactive attention signal as a "program interrupt" at the receiver end. When the OS generates an interrupt, this C++ signal interrupts the interrupt and allows the ongoing task to continue.

2. `SIGTERM`(Signal Termination) - This signal is generated by the kill command and is used to send a request to the running program for the termination of the incoming interrupt. The incoming signal is killed before it arrives to interrupt the ongoing execution of a task.

3. `SIGBUS`(Signal Bus) - When there is an indication of `BUS error`, it means there is access to an invalid address. This signal notifies the ongoing program that there is a `BUS error` gaining access to an invalid address and it is stopped.

4. `SIGILL`(Signal Illegal Instruction) - This signal is used to detect an illegal command or instruction, which could be the interrupt and pits a stop to it.

5. `SIGALRM`(Signal Alarm) - 	This signal uses the `alarm` function to indicate access to an invalid address (interrupt) by showing the expiration of time.

6. `SIGABRT`(Signal Abort) - This signal abnormally terminates the interrupt program.

7. `SIGSEGV`(Signal Segmentation Violation) - The signal shows and handles interrupts as storage with invalid access.

8. `SIGFPE`(Signal Floating-Point Exception) - This signal recognizes any erroneous or resultant overflowing mathematical operations such as a divide by zero.

9.	`SIGHUP`(Signal Hang up) - This signal is used to report to a process that its controlling terminal has been terminated by an interrupt. 

10.	`SIGQUIT`(Signal Quit) - This signal produced a core dump which is used the terminate the interrupt on its generation. 

11.	`SIGTRAP`(Signal Trap) - This signal is used to trace all traps (or exceptions) and sends information to the ongoing process about them, requesting termination. 

12.	`SIGCONT`(Signal Continue) - This signal is sent to the ongoing process to make it continue after an interrupt has been blocked or terminated. 

13.	`SIGSTOP`(Signal Stop) - This signal automatically terminates and blocks any interrupt that threatens to come up in a process.

The signals listed above can trap any interrupt (or exception) and resolve the problems.

### C++ Signal() function
#### How C++ signal() functions work
C++ `signal()` functions follow a string of processes that works relatively to bring the desired solution. 
The first thing to note is that there are two arguments represented in all signal functions and both play a vital role.

```c++
Syntax: signal(registered signal, signal handler);
```

The first argument, which is the `registered signal` and integer, gets registered with the signal function and the second argument, the `signal handler` works on catching all interrupts and exceptions through the C++ signals.

When the signal functions are compiled, they will generate an output. This output will be needed to create a visibly different interruption, meaning the signal used for catching interrupts would print them.

Following the process, another function called the `raise function` is included. This function considers the first argument and sends defined signals to the currently executing program. Raising a function generates a necessary signal.

**Note:** C++ signal handling function should be the `void` type.

Signal functions to note in the process include:

#### Prototypes
This signal function is defined in a `<csignal>` header file and describes a method of signal handling. 
Through the function, the handler can be set to perform one of the following actions:

 - Handling a signal by default
 - Handling the signal by ignoring it.
 - Handling the signal by a user-defined function

#### Parameters
This signal function comprises of `sig.` and `handler`. 
`sig.` is the signal that the signal handler handles. It can be either of the signals mentioned in the list below:

 - SIGABRT
 - SIGFPE
 - SIGILL
 - SIGINT
 - SIGSEGV
 - SIGTERM, etc.

`handler` is the signal handler. It can be either of the following:

 - `SIG_DFL`, "Default Handling", which handles the signal by its default action.

 - `SIG_IGN`, " Ignore Signal", handles the signal by ignoring it and continuing the code execution.

 - The "Function Handler", which handles the signal through the function defined by the user.

The signal should be: `void fun(int sig);`

#### Return value
This is the value that returns when the request of the function inputted is successful or not. 
If successful, it returns to the particular signal handler that was in charge of the command. But if it is not successful, `SIG_ERR` is returned.


### Implementation
The compilation below illustrates the implementation of a signal handling process using the `SIGINT` method.

```c++
#include <iostream>
#include <csignal>

using namespace std;

void signalHandler( int signum ) {
   cout << "Interrupt signal (" << signum << ") received.\n";

   // cleanup and close up stuff here  
   // terminate program  

   exit(signum);  
}

int main () {
   // register signal SIGINT and signal handler  
   signal(SIGINT, signalHandler);  

   while(1) {
      cout << "Going to sleep...." << endl;
      sleep(1);
   }

   return 0;
}
```

Once compiled and executed, the return value will indicate the following result: 

```
Going to sleep....
Going to sleep....
Going to sleep....
```

The compilation below illustrates the implementation of a signal handling process using the SIGABRT method.
```c++
#include <iostream>  
#include <csignal>  
   
using namespace std;  
  
sig_atomic_t sig_value = 0;  
  
void handler(int sig)  
{  
    sig_value = sig;  
}  
  
int main()  
{  
    signal(SIGABRT, handler);  
    cout << "Before signal handler is called" << endl;  
    cout << "Signal = " << sig_value << endl;   
    raise(SIGABRT);  
    cout << "After signal handler is called" << endl;  
    cout << "Signal = " << sig_value << endl;  
  
    return 0;  
}  
```
Once compiled and executed, the return value will indicate the following output:

```
Before signal handler is called
Signal = 0
After signal handler is called
Signal = 6
```

The compilation below illustrates the implementation of a signal handling process when the `SIGSEGV` method is used.

```c++
#include <csignal>   
#include <iostream>   
using namespace std;   
    
sig_atomic_t s_value = 0;   
void handle(int signal_)   
{   
    s_value = signal_;   
}   
    
int main()   
{   
    signal(SIGSEGV, handle);   
    cout << "Before called Signal = " << s_value << endl;   
    raise(SIGSEGV);   
    cout << "After called Signal = " << s_value << endl;   
    return 0;

```  

Once compiled and executed, the return value will indicate the following result:
```
Before called Signal = 0
After called Signal = 11
```

### Conclusion
In this article we have learned how to handle signals in C++ programming language. We have looked at signals operations and how they are implemented. 

### Further reading
You can learn more about other concepts by [visiting this page.](https://cppsecrets.com/users/6415115117114971071151049710997110100104971105349484864103109971051084699111109/C00-Signal-Handling-signal-function.php).
